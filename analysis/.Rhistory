install.packages('REDCapR')
library(REDCapR)
redcap_read(redcap_uri='https://redcap.laureateinstitute.org/redcap/api/', token='A6948348305C89AD77944FA12030B5F5', fields=c('record_id', 'redcap_event_name', 'medhx_assessed_at'))
redcap_read(redcap_uri='https://redcap.laureateinstitute.org/redcap/api/', token='A6948348305C89AD77944FA12030B5F5', fields=c('record_id', 'redcap_event_name', 'medhx_assessed_at'))
setwd("//isilon1/homefolders/rkuplicki/Documents/COBRE_Core")
setwd('..')
knitr::opts_chunk$set(echo = TRUE)
all_data <- read.csv('CPDD_EEGSycnronyData.csv')
#one eating disorder subject to include--also one mood/anxiety that has cocaine dependence and should be included
all_data$possible_subject <- (all_data$LC_Category == 'HC' | all_data$StimulantUser | all_data$OpioidUser) &
all_data$LC_Category != 'Eating+'
all_data$cpdd_group <- NA
all_data$cpdd_group[all_data$LC_Category == 'HC'] <- 'HC'
all_data$cpdd_group[all_data$StimulantUser] <- 'SUD'
all_data$cpdd_group[all_data$OpioidUser] <- 'OUD'
all_data$cpdd_group[all_data$StimulantUser & all_data$OpioidUser] <- 'SUD+OUD'
print('All T500 subjects that are HC or SUD/OUD')
table(all_data$cpdd_group[all_data$possible_subject])
print('All Subjects with good low-motion resting state data')
rest_inclusion <- all_data$rest_motave < 0.2
rest_inclusion[is.na(rest_inclusion)] <- FALSE
all_data$possible_subject <- all_data$possible_subject & rest_inclusion
table(all_data$cpdd_group[all_data$possible_subject])
print('All Subjects that also have good EEG data')
eeg_include <- !is.na(all_data$Delta_Left)
all_data$possible_subject <- all_data$possible_subject & eeg_include
table(all_data$cpdd_group[all_data$possible_subject])
print('Could include another 17 subjects by re-running their resting state processing, probably')
sum(is.na(all_data$BOLD_Left) & all_data$possible_subject)
all_data$possible_subject <- all_data$possible_subject & (!is.na(all_data$BOLD_Left))
print('Final subjects to use now:')
table(all_data$cpdd_group[all_data$possible_subject])
selected_data <- all_data[all_data$possible_subject,]
library(tableone)
print(CreateTableOne(data = selected_data, strata = 'cpdd_group', vars = c('Age', 'Gender', 'InBody_BMI', 'DAST', 'CDDR_NegReinforcement',
'CDDR_PosReinforcement', 'rest_motave', 'DaysSinceLastIllicitUse',
'PROMIS_AlcoUseTscore', 'PROMIS_NicDependenceTscore',
'PHQ', 'OASIS', 'PROMIS_DepressTscore', 'PROMIS_AnxietyTscore')))
write.csv(selected_data, 'SynchronyDataUsed.csv', row.names = FALSE)
library(devtools)
install.packages('devtools')
library(devtools)
devtools::install_github('kforthman/caretStack')
devtools::install_github('kforthman/caretStack')
library(caretStack)
?caretStack
??caretStack
library(REDCapR)
?redcap_read
redcap_read
t1000_consents <- redcap_read(redcap_uri='https://redcap.laureateinstitute.org/redcap/api/', token='FF2468E74E84225DA93DE77CEA706B80', fields=c('mric_path'))
knitr::opts_chunk$set(echo = TRUE)
#function to be able to read in an .RData file and assign it to a variable
loadRData <- function(fileName){
#loads an RData file, and returns it
load(fileName)
get(ls()[ls() != "fileName"])
}
#so re-running gives the same results
set.seed(1234)
#read in demographics data
demo_data <- loadRData('../Data/nda18_2.0_demovars.RDATA')
#grab just the baseline data, so we'll only have one row per subject
demo_data <- demo_data[demo_data$eventname == 'baseline_year_1_arm_1',]
#read in imaging data to get which participants have good structurals
#will only use participants with fsqc_qc == 1
fs_data <- loadRData('../Data/nda18_2.0_FS_cort_subcort.RDATA')
fs_data <- fs_data[fs_data$eventname == 'baseline_year_1_arm_1',]
merged_data <- merge(fs_data, demo_data)
#will only use subjects with CBCL data, i.e. !is.na(merged_data$cbcl_scr_syn_external_t)
cbcl_data <- loadRData('../Data/nda18_2.0_CBCL.RDATA')
cbcl_data <- cbcl_data[cbcl_data$eventname == 'baseline_year_1_arm_1',]
merged_data <- merge(merged_data, cbcl_data)
n_total <- nrow(merged_data)
print(paste('Total participants:', n_total))
selected_data <- merged_data[!is.na(merged_data$fsqc_qc),]
selected_data <- selected_data[selected_data$fsqc_qc == 1,]
n_goodfs <- nrow(selected_data)
n_excluded_fs <- n_total - n_goodfs
print(paste('After excluding',  n_excluded_fs, 'for poor structural data based on `fsqc_qc == 1`:', n_goodfs))
selected_data <- selected_data[!is.na(selected_data$cbcl_scr_syn_external_t),]
n_final <- nrow(selected_data)
n_excluded_cbcl <- n_goodfs - n_final
print(paste('After excluding', n_excluded_cbcl, 'for missing CBCL data:', n_final))
#three subjects have sex listed as blank (but not NA, and not exactly ' ' either)--fix that here
invalid_sex <- selected_data$sex[!(selected_data$sex %in% c('M', 'F'))]
selected_data$sex[selected_data$sex %in% invalid_sex] <- NA
selected_data$sex <- factor(selected_data$sex, levels = unique(selected_data$sex))
#generate five possible splits and summarize using tableone
library(tableone)
#will split on FamilyID, then even up # in each set if necessary
family_ids <- unique(selected_data$FamilyID)
n_families <- length(family_ids)
#will pick this many families for training set, others for testing
n_families_training <- floor(n_families * 0.8)
selected_data$race.ethnicity
library(caret)
train
?train
?trainControl
?aggregate
library(tableone)
?CreateTableOne
setwd("L:/NPC/Analysis/rkuplicki/repos/LIBR_MOCD/analysis")
